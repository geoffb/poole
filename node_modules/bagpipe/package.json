{
  "name": "bagpipe",
  "version": "0.2.0",
  "description": "bagpipe.js",
  "keywords": [
    "limiter",
    "concurrency limit",
    "parallel limit"
  ],
  "main": "index.js",
  "scripts": {
    "test": "mocha -R spec"
  },
  "dependencies": {
    "mocha": "*",
    "should": "*"
  },
  "author": {
    "name": "Jackson Tian"
  },
  "license": "MIT",
  "readme": "Bagpipe(风笛)\n=======\nYou are the bagpiper.  \n\n## 起源\n在Node中我们可以十分方便利用异步和并行来提升我们的业务速度。但是，如果并发量过大，我们的服务器却可能吃不消，我们需要限制并发量。尽管`http`模块自身有[http.Agent](http://nodejs.org/docs/latest/api/http.html#http_class_http_agent)这样的玩意，用于控制socket的数量，但是通常我们的异步API早就封装好了。改动API的内部agent是不现实的，那么我们自己在逻辑层实现吧。\n\n## 安装\n```\nnpm install bagpipe\n```\n\n## API\n`Bagpipe`暴露的API只有构造器和实例方法`push`。\n\n在原始状态下，我们执行并发可能是如下这样的，这会形成100个并发异步调用。\n\n```\nfor (var i = 0; i < 100; i++) {\n  async(function () {\n    // 异步调用\n  });\n}\n```\n如果需要限制并发，你的方案会是怎样？\n\n`Bagpipe`的方案是如下这样的：\n\n```\nvar Bagpipe = require('bagpipe');\n// 设定最大并发数为10\nvar bagpipe = new Bagpipe(10);\nfor (var i = 0; i < 100; i++) {\n  bagpipe.push(async, function () {\n    // 异步回调执行\n  });\n}\n```\n\n是的，调用方式仅仅是将方法、参数、回调分拆一下通过`push`交给`bagpipe`即可。\n\n这个方案与你预想的方案相比，如何？\n\n## 原理\n`Bagpipe`通过`push`将调用传入内部队列。如果活跃调用小于最大并发数，将会被取出直接执行，反之则继续呆在队列中。当一个异步调用结束的时候，会从队列前取出调用执行。以此来保证异步调用的活跃量不高于限定值。  \n当队列的长度大于100或者大于最大并发数的2倍时，Bagpipe对象将会触发它的`full`事件，该事件传递队列长度值。该值有助于评估业务性能参数。示例如下：\n\n```\nbagpipe.on('full', function (length) {\n  console.warn('底层系统处理不能及时完成，队列拥堵，目前队列长度为:' + length);\n});\n```\n\n## 模块状态\n单元测试通过状态：[![Build Status](https://secure.travis-ci.org/JacksonTian/bagpipe.png)](http://travis-ci.org/JacksonTian/bagpipe)。单元测试覆盖率[100%](http://html5ify.com/bagpipe/coverage.html)。\n\n## 最佳实践\n- 确保异步调用的最后一个参数为回调参数\n- 监听`full`事件，以增加你对业务性能的评估\n- 目前异步方法未支持上下文。确保异步方法内部没有`this`引用\n- 异步调用应当具备timeout的业务处理，无论业务是否完成，总在一定的时间内保证返回\n\n## 实际案例\n当你需要遍历文件目录的时候，异步可以确保充分利用IO。你可以轻松发起成千上万个文件的读取。但是，系统文件描述符是有限的。不服的话，遇见下面这个错误再来重读此文。\n\n```\nError: EMFILE, too many open files\n```\n也有人会考虑用同步方法来进行处理。但是，同步时，CPU与IO并不能并行利用，一定情况下，性能是不可弃的一项指标。用上`Bagpipe`，可以轻松享受并发，也能限制并发。\n\n```\nvar bagpipe = new Bagpipe(10);\n\nvar files = ['这里有很多很多文件'];\nfor (var i = 0; i < files.length; i++) {\n  // fs.readFile(files[i], 'utf-8', function (err, data) {\n  bagpipe.push(fs.readFile, files[i], 'utf-8', function (err, data) {\n    // 不会因为文件描述符过多出错\n    // 妥妥的\n  });\n}\n```\n\n## License\n在[MIT](https://github.com/JacksonTian/bagpipe/blob/master/MIT-License)许可证下发布，欢迎享受开源\n\n",
  "readmeFilename": "README.md",
  "_id": "bagpipe@0.2.0",
  "dist": {
    "shasum": "4f3b584f5f0e2900c058a276eac30155f6478860"
  },
  "_from": "bagpipe"
}
